
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_EEG_Example.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_EEG_Example.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_EEG_Example.py:


=================================
Epilepsy Detection Using EEG Data
=================================

In this example we'll use the |cesium|_ library to compare
various techniques for epilepsy detection using a classic EEG time series dataset from
`Andrzejak et al.  <http://www.meb.uni-bonn.de/epileptologie/science/physik/eegdata.html>`_.
The raw data are separated into five classes: Z, O, N, F, and S; we will consider a
three-class classification problem of distinguishing normal (Z, O), interictal (N, F), and
ictal (S) signals.

The overall workflow consists of three steps: first, we "featurize" the time series by
selecting some set of mathematical functions to apply to each; next, we build some
classification models which use these features to distinguish between classes;
finally, we validate our models by generating predictions for some unseen
holdout set and comparing them to the true class labels.

First, we'll load the data and inspect a representative time series from each class:

.. |cesium| replace:: ``cesium``
.. _cesium: https://github.com/cesium-ml/cesium

.. GENERATED FROM PYTHON SOURCE LINES 24-49

.. code-block:: Python


    import numpy as np
    import matplotlib.pyplot as plt
    import seaborn
    from cesium import datasets

    seaborn.set()

    eeg = datasets.fetch_andrzejak()

    # Group together classes (Z, O), (N, F), (S) as normal, interictal, ictal
    eeg["classes"] = eeg["classes"].astype("U16")  # allocate memory for longer class names
    eeg["classes"][np.logical_or(eeg["classes"] == "Z", eeg["classes"] == "O")] = "Normal"
    eeg["classes"][
        np.logical_or(eeg["classes"] == "N", eeg["classes"] == "F")
    ] = "Interictal"
    eeg["classes"][eeg["classes"] == "S"] = "Ictal"

    fig, ax = plt.subplots(1, len(np.unique(eeg["classes"])), sharey=True)
    for label, subplot in zip(np.unique(eeg["classes"]), ax):
        i = np.where(eeg["classes"] == label)[0][0]
        subplot.plot(eeg["times"][i], eeg["measurements"][i])
        subplot.set(xlabel="time (s)", ylabel="signal", title=label)





.. image-sg:: /auto_examples/images/sphx_glr_plot_EEG_Example_001.png
   :alt: Ictal, Interictal, Normal
   :srcset: /auto_examples/images/sphx_glr_plot_EEG_Example_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading data from https://github.com/cesium-ml/cesium-data/raw/main/andrzejak/




.. GENERATED FROM PYTHON SOURCE LINES 50-65

Featurization
-------------
Once the data is loaded, we can generate features for each time series using the
|cesium.featurize|_ module. The ``featurize`` module includes many built-in
choices of features which can be applied for any type of time series data;
here we've chosen a few generic features that do not have any special
biological significance.

By default, the time series will featurized in parallel using the
``dask.threaded`` scheduler; other approaches, including serial and
distributed approaches, can be implemented by passing in other ``dask``
schedulers as the ``get`` argument to ``featurize_time_series``.

.. |cesium.featurize| replace:: ``cesium.featurize``
.. _cesium.featurize: http://cesium-ml.org/docs/api/cesium.featurize.html

.. GENERATED FROM PYTHON SOURCE LINES 65-89

.. code-block:: Python


    from cesium import featurize

    features_to_use = [
        "amplitude",
        "percent_beyond_1_std",
        "maximum",
        "max_slope",
        "median",
        "median_absolute_deviation",
        "percent_close_to_median",
        "minimum",
        "skew",
        "std",
        "weighted_average",
    ]
    fset_cesium = featurize.featurize_time_series(
        times=eeg["times"],
        values=eeg["measurements"],
        errors=None,
        features_to_use=features_to_use,
    )
    print(fset_cesium.head())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    feature amplitude percent_beyond_1_std  ...        std weighted_average
    channel         0                    0  ...          0                0
    0           143.5             0.327313  ...  40.411000        -4.132048
    1           211.5             0.290212  ...  48.812668       -52.444716
    2           165.0             0.302660  ...  47.144789        12.705150
    3           171.5             0.300952  ...  47.072316        -3.992433
    4           170.0             0.305101  ...  44.910958       -17.999268

    [5 rows x 11 columns]




.. GENERATED FROM PYTHON SOURCE LINES 90-95

The output of ``featurize_time_series`` is a ``pandas.DataFrame`` which contains all
the feature information needed to train a machine learning model: feature
names are stored as column indices (as well as channel numbers, as we'll see
later for multi-channel data), and the time series index/class label are
stored as row indices.

.. GENERATED FROM PYTHON SOURCE LINES 97-107

Custom feature functions
~~~~~~~~~~~~~~~~~~~~~~~~
Custom feature functions not built into ``cesium`` may be passed in using the
``custom_functions`` keyword, either as a dictionary ``{feature_name: function}``, or as a
`dask graph <http://dask.pydata.org/en/latest/custom-graphs.html>`_. Functions should take
three arrays ``times, measurements, errors`` as inputs; details can be found in the
``cesium.featurize``
`documentation <http://cesium-ml.org/docs/api/cesium.featurize.html>`_.
Here we'll compute five standard features for EEG analysis provided by
`Guo et al. (2012) <http://linkinghub.elsevier.com/retrieve/pii/S0957417411003253)>`_:

.. GENERATED FROM PYTHON SOURCE LINES 107-132

.. code-block:: Python


    import numpy as np
    import scipy.stats


    def mean_signal(t, m, e):
        return np.mean(m)


    def std_signal(t, m, e):
        return np.std(m)


    def mean_square_signal(t, m, e):
        return np.mean(m**2)


    def abs_diffs_signal(t, m, e):
        return np.sum(np.abs(np.diff(m)))


    def skew_signal(t, m, e):
        return scipy.stats.skew(m)









.. GENERATED FROM PYTHON SOURCE LINES 133-135

Now we'll pass the desired feature functions as a dictionary via the
``custom_functions`` keyword argument.

.. GENERATED FROM PYTHON SOURCE LINES 135-153

.. code-block:: Python


    guo_features = {
        "mean": mean_signal,
        "std": std_signal,
        "mean2": mean_square_signal,
        "abs_diffs": abs_diffs_signal,
        "skew": skew_signal,
    }

    fset_guo = featurize.featurize_time_series(
        times=eeg["times"],
        values=eeg["measurements"],
        errors=None,
        features_to_use=list(guo_features.keys()),
        custom_functions=guo_features,
    )
    print(fset_guo.head())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    feature       mean        std        mean2 abs_diffs      skew
    channel          0          0            0         0         0
    0        -4.132048  40.411000  1650.122773   46948.0  0.032805
    1       -52.444716  48.812668  5133.124725   61118.0 -0.092715
    2        12.705150  47.144789  2384.051989   51269.0 -0.004100
    3        -3.992433  47.072316  2231.742495   75014.0  0.063678
    4       -17.999268  44.910958  2340.967781   52873.0  0.142753




.. GENERATED FROM PYTHON SOURCE LINES 154-162

Multi-channel time series
~~~~~~~~~~~~~~~~~~~~~~~~~
The EEG time series considered here consist of univariate signal measurements along a
uniform time grid. But ``featurize_time_series`` also accepts multi-channel
data; to demonstrate this, we will decompose each signal into five frequency
bands using a discrete wavelet transform as suggested by
`Subasi (2005) <http://www.sciencedirect.com/science/article/pii/S0957417404001745>`_,
and then featurize each band separately using the five functions from above.

.. GENERATED FROM PYTHON SOURCE LINES 162-179

.. code-block:: Python


    import pywt

    n_channels = 5
    eeg["dwts"] = [
        pywt.wavedec(m, pywt.Wavelet("db1"), level=n_channels - 1)
        for m in eeg["measurements"]
    ]
    fset_dwt = featurize.featurize_time_series(
        times=None,
        values=eeg["dwts"],
        errors=None,
        features_to_use=list(guo_features.keys()),
        custom_functions=guo_features,
    )
    print(fset_dwt.head())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    feature        mean                      ...      skew                    
    channel           0         1         2  ...         2         3         4
    0        -17.080739 -6.067121 -0.979336  ...  0.299892  0.123948  0.117937
    1       -210.210117 -3.743191  0.511377  ...  0.168179 -0.005521  0.187815
    2         51.831712  0.714981  0.247418  ... -0.254241 -0.061304 -0.136422
    3        -15.429961  9.348249 -0.099243  ... -0.013705 -0.007339  0.013836
    4        -71.982490 -3.787938 -0.183324  ...  0.285906  0.087555  0.066677

    [5 rows x 25 columns]




.. GENERATED FROM PYTHON SOURCE LINES 180-183

The output featureset has the same form as before, except now the ``channel``
component of the column index is used to index the features by the
corresponding frequency band.

.. GENERATED FROM PYTHON SOURCE LINES 185-192

Model Building
--------------
Featuresets produced by ``cesium.featurize`` are compatible with the ``scikit-learn``
API. For this example, we'll test a random forest classifier for the
built-in ``cesium`` features, and a 3-nearest neighbors classifier for the
others, as suggested by
`Guo et al. (2012) <http://linkinghub.elsevier.com/retrieve/pii/S0957417411003253>`_.

.. GENERATED FROM PYTHON SOURCE LINES 192-208

.. code-block:: Python


    from sklearn.ensemble import RandomForestClassifier
    from sklearn.neighbors import KNeighborsClassifier
    from sklearn.model_selection import train_test_split

    train, test = train_test_split(np.arange(len(eeg["classes"])), random_state=0)

    model_cesium = RandomForestClassifier(n_estimators=128, random_state=0)
    model_cesium.fit(fset_cesium.iloc[train], eeg["classes"][train])

    model_guo = KNeighborsClassifier(3)
    model_guo.fit(fset_guo.iloc[train], eeg["classes"][train])

    model_dwt = KNeighborsClassifier(3)
    model_dwt.fit(fset_dwt.iloc[train], eeg["classes"][train])






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-1 {
      /* Definition of color scheme common for light and dark mode */
      --sklearn-color-text: black;
      --sklearn-color-line: gray;
      /* Definition of color scheme for unfitted estimators */
      --sklearn-color-unfitted-level-0: #fff5e6;
      --sklearn-color-unfitted-level-1: #f6e4d2;
      --sklearn-color-unfitted-level-2: #ffe0b3;
      --sklearn-color-unfitted-level-3: chocolate;
      /* Definition of color scheme for fitted estimators */
      --sklearn-color-fitted-level-0: #f0f8ff;
      --sklearn-color-fitted-level-1: #d4ebff;
      --sklearn-color-fitted-level-2: #b3dbfd;
      --sklearn-color-fitted-level-3: cornflowerblue;

      /* Specific color for light theme */
      --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
      --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
      --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
      --sklearn-color-icon: #696969;

      @media (prefers-color-scheme: dark) {
        /* Redefinition of color scheme for dark theme */
        --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
        --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
        --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
        --sklearn-color-icon: #878787;
      }
    }

    #sk-container-id-1 {
      color: var(--sklearn-color-text);
    }

    #sk-container-id-1 pre {
      padding: 0;
    }

    #sk-container-id-1 input.sk-hidden--visually {
      border: 0;
      clip: rect(1px 1px 1px 1px);
      clip: rect(1px, 1px, 1px, 1px);
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      width: 1px;
    }

    #sk-container-id-1 div.sk-dashed-wrapped {
      border: 1px dashed var(--sklearn-color-line);
      margin: 0 0.4em 0.5em 0.4em;
      box-sizing: border-box;
      padding-bottom: 0.4em;
      background-color: var(--sklearn-color-background);
    }

    #sk-container-id-1 div.sk-container {
      /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
         but bootstrap.min.css set `[hidden] { display: none !important; }`
         so we also need the `!important` here to be able to override the
         default hidden behavior on the sphinx rendered scikit-learn.org.
         See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
      display: inline-block !important;
      position: relative;
    }

    #sk-container-id-1 div.sk-text-repr-fallback {
      display: none;
    }

    div.sk-parallel-item,
    div.sk-serial,
    div.sk-item {
      /* draw centered vertical line to link estimators */
      background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
      background-size: 2px 100%;
      background-repeat: no-repeat;
      background-position: center center;
    }

    /* Parallel-specific style estimator block */

    #sk-container-id-1 div.sk-parallel-item::after {
      content: "";
      width: 100%;
      border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
      flex-grow: 1;
    }

    #sk-container-id-1 div.sk-parallel {
      display: flex;
      align-items: stretch;
      justify-content: center;
      background-color: var(--sklearn-color-background);
      position: relative;
    }

    #sk-container-id-1 div.sk-parallel-item {
      display: flex;
      flex-direction: column;
    }

    #sk-container-id-1 div.sk-parallel-item:first-child::after {
      align-self: flex-end;
      width: 50%;
    }

    #sk-container-id-1 div.sk-parallel-item:last-child::after {
      align-self: flex-start;
      width: 50%;
    }

    #sk-container-id-1 div.sk-parallel-item:only-child::after {
      width: 0;
    }

    /* Serial-specific style estimator block */

    #sk-container-id-1 div.sk-serial {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: var(--sklearn-color-background);
      padding-right: 1em;
      padding-left: 1em;
    }


    /* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
    clickable and can be expanded/collapsed.
    - Pipeline and ColumnTransformer use this feature and define the default style
    - Estimators will overwrite some part of the style using the `sk-estimator` class
    */

    /* Pipeline and ColumnTransformer style (default) */

    #sk-container-id-1 div.sk-toggleable {
      /* Default theme specific background. It is overwritten whether we have a
      specific estimator or a Pipeline/ColumnTransformer */
      background-color: var(--sklearn-color-background);
    }

    /* Toggleable label */
    #sk-container-id-1 label.sk-toggleable__label {
      cursor: pointer;
      display: block;
      width: 100%;
      margin-bottom: 0;
      padding: 0.5em;
      box-sizing: border-box;
      text-align: center;
    }

    #sk-container-id-1 label.sk-toggleable__label-arrow:before {
      /* Arrow on the left of the label */
      content: "▸";
      float: left;
      margin-right: 0.25em;
      color: var(--sklearn-color-icon);
    }

    #sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {
      color: var(--sklearn-color-text);
    }

    /* Toggleable content - dropdown */

    #sk-container-id-1 div.sk-toggleable__content {
      max-height: 0;
      max-width: 0;
      overflow: hidden;
      text-align: left;
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-0);
    }

    #sk-container-id-1 div.sk-toggleable__content.fitted {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-0);
    }

    #sk-container-id-1 div.sk-toggleable__content pre {
      margin: 0.2em;
      border-radius: 0.25em;
      color: var(--sklearn-color-text);
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-0);
    }

    #sk-container-id-1 div.sk-toggleable__content.fitted pre {
      /* unfitted */
      background-color: var(--sklearn-color-fitted-level-0);
    }

    #sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {
      /* Expand drop-down */
      max-height: 200px;
      max-width: 100%;
      overflow: auto;
    }

    #sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
      content: "▾";
    }

    /* Pipeline/ColumnTransformer-specific style */

    #sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
      color: var(--sklearn-color-text);
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    #sk-container-id-1 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
      background-color: var(--sklearn-color-fitted-level-2);
    }

    /* Estimator-specific style */

    /* Colorize estimator box */
    #sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    #sk-container-id-1 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-2);
    }

    #sk-container-id-1 div.sk-label label.sk-toggleable__label,
    #sk-container-id-1 div.sk-label label {
      /* The background is the default theme color */
      color: var(--sklearn-color-text-on-default-background);
    }

    /* On hover, darken the color of the background */
    #sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {
      color: var(--sklearn-color-text);
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    /* Label box, darken color on hover, fitted */
    #sk-container-id-1 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
      color: var(--sklearn-color-text);
      background-color: var(--sklearn-color-fitted-level-2);
    }

    /* Estimator label */

    #sk-container-id-1 div.sk-label label {
      font-family: monospace;
      font-weight: bold;
      display: inline-block;
      line-height: 1.2em;
    }

    #sk-container-id-1 div.sk-label-container {
      text-align: center;
    }

    /* Estimator-specific */
    #sk-container-id-1 div.sk-estimator {
      font-family: monospace;
      border: 1px dotted var(--sklearn-color-border-box);
      border-radius: 0.25em;
      box-sizing: border-box;
      margin-bottom: 0.5em;
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-0);
    }

    #sk-container-id-1 div.sk-estimator.fitted {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-0);
    }

    /* on hover */
    #sk-container-id-1 div.sk-estimator:hover {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    #sk-container-id-1 div.sk-estimator.fitted:hover {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-2);
    }

    /* Specification for estimator info (e.g. "i" and "?") */

    /* Common style for "i" and "?" */

    .sk-estimator-doc-link,
    a:link.sk-estimator-doc-link,
    a:visited.sk-estimator-doc-link {
      float: right;
      font-size: smaller;
      line-height: 1em;
      font-family: monospace;
      background-color: var(--sklearn-color-background);
      border-radius: 1em;
      height: 1em;
      width: 1em;
      text-decoration: none !important;
      margin-left: 1ex;
      /* unfitted */
      border: var(--sklearn-color-unfitted-level-1) 1pt solid;
      color: var(--sklearn-color-unfitted-level-1);
    }

    .sk-estimator-doc-link.fitted,
    a:link.sk-estimator-doc-link.fitted,
    a:visited.sk-estimator-doc-link.fitted {
      /* fitted */
      border: var(--sklearn-color-fitted-level-1) 1pt solid;
      color: var(--sklearn-color-fitted-level-1);
    }

    /* On hover */
    div.sk-estimator:hover .sk-estimator-doc-link:hover,
    .sk-estimator-doc-link:hover,
    div.sk-label-container:hover .sk-estimator-doc-link:hover,
    .sk-estimator-doc-link:hover {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-3);
      color: var(--sklearn-color-background);
      text-decoration: none;
    }

    div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
    .sk-estimator-doc-link.fitted:hover,
    div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
    .sk-estimator-doc-link.fitted:hover {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-3);
      color: var(--sklearn-color-background);
      text-decoration: none;
    }

    /* Span, style for the box shown on hovering the info icon */
    .sk-estimator-doc-link span {
      display: none;
      z-index: 9999;
      position: relative;
      font-weight: normal;
      right: .2ex;
      padding: .5ex;
      margin: .5ex;
      width: min-content;
      min-width: 20ex;
      max-width: 50ex;
      color: var(--sklearn-color-text);
      box-shadow: 2pt 2pt 4pt #999;
      /* unfitted */
      background: var(--sklearn-color-unfitted-level-0);
      border: .5pt solid var(--sklearn-color-unfitted-level-3);
    }

    .sk-estimator-doc-link.fitted span {
      /* fitted */
      background: var(--sklearn-color-fitted-level-0);
      border: var(--sklearn-color-fitted-level-3);
    }

    .sk-estimator-doc-link:hover span {
      display: block;
    }

    /* "?"-specific style due to the `<a>` HTML tag */

    #sk-container-id-1 a.estimator_doc_link {
      float: right;
      font-size: 1rem;
      line-height: 1em;
      font-family: monospace;
      background-color: var(--sklearn-color-background);
      border-radius: 1rem;
      height: 1rem;
      width: 1rem;
      text-decoration: none;
      /* unfitted */
      color: var(--sklearn-color-unfitted-level-1);
      border: var(--sklearn-color-unfitted-level-1) 1pt solid;
    }

    #sk-container-id-1 a.estimator_doc_link.fitted {
      /* fitted */
      border: var(--sklearn-color-fitted-level-1) 1pt solid;
      color: var(--sklearn-color-fitted-level-1);
    }

    /* On hover */
    #sk-container-id-1 a.estimator_doc_link:hover {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-3);
      color: var(--sklearn-color-background);
      text-decoration: none;
    }

    #sk-container-id-1 a.estimator_doc_link.fitted:hover {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-3);
    }
    </style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>KNeighborsClassifier(n_neighbors=3)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked><label for="sk-estimator-id-1" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;&nbsp;KNeighborsClassifier<a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.4/modules/generated/sklearn.neighbors.KNeighborsClassifier.html">?<span>Documentation for KNeighborsClassifier</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>KNeighborsClassifier(n_neighbors=3)</pre></div> </div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 209-215

Prediction
----------
Making predictions for new time series based on these models follows the same
pattern: first the time series are featurized using ``featurize_time_series``,
and then predictions are made based on these features using the ``predict``
method of the ``scikit-learn`` model.

.. GENERATED FROM PYTHON SOURCE LINES 215-241

.. code-block:: Python


    from sklearn.metrics import accuracy_score

    preds_cesium = model_cesium.predict(fset_cesium)
    preds_guo = model_guo.predict(fset_guo)
    preds_dwt = model_dwt.predict(fset_dwt)

    print(
        "Built-in cesium features: training accuracy={:.2%}, test accuracy={:.2%}".format(
            accuracy_score(preds_cesium[train], eeg["classes"][train]),
            accuracy_score(preds_cesium[test], eeg["classes"][test]),
        )
    )
    print(
        "Guo et al. features: training accuracy={:.2%}, test accuracy={:.2%}".format(
            accuracy_score(preds_guo[train], eeg["classes"][train]),
            accuracy_score(preds_guo[test], eeg["classes"][test]),
        )
    )
    print(
        "Wavelet transform features: training accuracy={:.2%}, test accuracy={:.2%}".format(
            accuracy_score(preds_dwt[train], eeg["classes"][train]),
            accuracy_score(preds_dwt[test], eeg["classes"][test]),
        )
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Built-in cesium features: training accuracy=100.00%, test accuracy=83.20%
    Guo et al. features: training accuracy=92.80%, test accuracy=83.20%
    Wavelet transform features: training accuracy=97.87%, test accuracy=95.20%




.. GENERATED FROM PYTHON SOURCE LINES 242-250

The workflow presented here is intentionally simplistic and omits many important steps
such as feature selection, model parameter selection, etc., which may all be
incorporated just as they would for any other ``scikit-learn`` analysis.
But with essentially three function calls (``featurize_time_series``,
``model.fit``, and ``model.predict``), we are able to build a
model from a set of time series and make predictions on new, unlabeled data. In
upcoming posts we'll introduce the web frontend for ``cesium`` and describe how
the same analysis can be performed in a browser with no setup or coding required.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 14.467 seconds)


.. _sphx_glr_download_auto_examples_plot_EEG_Example.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_EEG_Example.ipynb <plot_EEG_Example.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_EEG_Example.py <plot_EEG_Example.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
